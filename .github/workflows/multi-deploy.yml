name: multi-deploy

on:
  workflow_dispatch:
    inputs:
      env_list:
        description: 'customer ids to deploy (comma-separated, no spaces)'
        required: true
        default: ''
      branch:
        description: 'Git branch'
        required: true
        default: 'main'
      git_hash:
        description: 'Git commit hash'
        required: true
        default: ''

jobs:
  deploy-sequentially:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1
      
      - name: Process deployments sequentially
        id: deploy-loop
        run: |
          # Get the list of environments
          ENV_LIST="${{ github.event.inputs.env_list }}"
          BRANCH="${{ github.event.inputs.branch }}"
          GIT_HASH="${{ github.event.inputs.git_hash }}"
          
          # Split into array
          IFS=',' read -ra ENVS <<< "$ENV_LIST"
          
          # Initialize arrays for completed and pending
          COMPLETED=()
          PENDING=("${ENVS[@]}")
          
          echo "Starting sequential deployments of ${#ENVS[@]} environments"
          echo "Full environment list: $ENV_LIST"
          
          # Process each environment
          for ENV in "${ENVS[@]}"; do
            echo "===== Processing environment: $ENV ====="
            
            # Remove current env from pending and add to completed
            COMPLETED+=("$ENV")
            
            # Rebuild the pending list without the current env
            NEW_PENDING=()
            for PEND in "${PENDING[@]}"; do
              if [ "$PEND" != "$ENV" ]; then
                NEW_PENDING+=("$PEND")
              fi
            done
            PENDING=("${NEW_PENDING[@]}")
            
            # Convert arrays to comma-separated strings
            COMPLETED_STR=$(IFS=,; echo "${COMPLETED[*]}")
            PENDING_STR=$(IFS=,; echo "${PENDING[*]}")
            
            echo "Completed: $COMPLETED_STR"
            echo "Pending: $PENDING_STR"
            
            # First, update the gist with the current build status before starting the build
            echo "Updating deployment status in gist before build..."
            echo '{
              "ref": "${{ github.ref_name }}",
              "inputs": {
                "completed_deploys": "'$COMPLETED_STR'",
                "pending_deploys": "'$PENDING_STR'",
                "branch": "'$BRANCH'",
                "git_hash": "'$GIT_HASH'"
              }
            }' > payload.json

            cat payload.json
            
            # Update the gist by calling the update-deploy-status workflow
            curl -s -X POST \
              -H "Authorization: token $MY_GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/update-deploy-status.yml/dispatches" \
              -d @payload.json
            
            # Wait briefly for the status update workflow to start
            sleep 2
            
            echo "Status update triggered for environment: $ENV"
            
            # Now call manual-build workflow
            echo "Calling manual-build for environment $ENV..."
            
            # Create payload for manual-build workflow
            MANUAL_BUILD_PAYLOAD="{\"ref\":\"main\",\"inputs\":{ \"GIT_BRANCH\": \"$BRANCH\", \"ENVIRONMENT\": \"$ENV\", \"SKIP_TESTS\": \"true\" }}"
            
            echo "manual-build payload: $MANUAL_BUILD_PAYLOAD"
            
            # Call the manual-build workflow and capture the response
            RESPONSE=$(curl -s -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $MY_GITHUB_TOKEN" \
              "https://api.github.com/repos/atex-ci/nikita-runner/actions/workflows/manual-build.yml/dispatches" \
              -d "$MANUAL_BUILD_PAYLOAD")
            
            echo "manual-build trigger response: $RESPONSE"
            echo "manual-build triggered for environment: $ENV"
            
            # Wait for the workflow to complete
            echo "Waiting for manual-build workflow to complete..."
            
            # First, we need to get the workflow runs
            # Sleep a bit to make sure the workflow has been registered
            sleep 5
            
            # Check workflow status every 30 seconds until complete
            WORKFLOW_COMPLETE=false
            MAX_ATTEMPTS=60  # Maximum wait time: 30 minutes
            ATTEMPT=0
            
            while [ "$WORKFLOW_COMPLETE" = false ] && [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
              # Get the latest run of the workflow
              RUNS_RESPONSE=$(curl -s \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $MY_GITHUB_TOKEN" \
                "https://api.github.com/repos/atex-ci/nikita-runner/actions/workflows/manual-build.yml/runs?branch=main&per_page=5")
              
              # Extract the status of the latest run (the first one in the list)
              # Using grep and cut to extract the conclusion value
              # This assumes jq is not available on the runner
              RUN_STATUS=$(echo "$RUNS_RESPONSE" | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4)
              RUN_CONCLUSION=$(echo "$RUNS_RESPONSE" | grep -o '"conclusion":"[^"]*"' | head -1 | cut -d'"' -f4)
              
              echo "Current workflow status: $RUN_STATUS, conclusion: $RUN_CONCLUSION"
              
              # Check if the workflow has completed
              if [ "$RUN_STATUS" = "completed" ]; then
                WORKFLOW_COMPLETE=true
                echo "Workflow completed with conclusion: $RUN_CONCLUSION"
                
                # Check if the workflow failed
                if [ "$RUN_CONCLUSION" != "success" ]; then
                  echo "WARNING: Workflow did not complete successfully! Conclusion: $RUN_CONCLUSION"
                fi
              else
                echo "Workflow still running. Waiting 30 seconds before checking again. Attempt $ATTEMPT of $MAX_ATTEMPTS"
                sleep 30
                ATTEMPT=$((ATTEMPT + 1))
              fi
            done
            
            if [ "$WORKFLOW_COMPLETE" = false ]; then
              echo "WARNING: Timed out waiting for workflow to complete! Moving on to next environment."
            fi
          done
          
          # Final update to ensure no pending builds in the gist
          echo "Performing final status update to clear any pending builds..."
          
          # Create payload file for final update
          echo '{
            "ref": "${{ github.ref_name }}",
            "inputs": {
              "completed_deploys": "'$COMPLETED_STR'",
              "pending_deploys": "",
              "branch": "'$BRANCH'",
              "git_hash": "'$GIT_HASH'"
            }
          }' > final_payload.json

          cat final_payload.json
          
          # Final update of the gist
          curl -s -X POST \
            -H "Authorization: token $MY_GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/update-deploy-status.yml/dispatches" \
            -d @final_payload.json
          
          echo "All deployments have been completed and status has been finalized!"
        env:
          MY_GITHUB_TOKEN: ${{ secrets.GH_PASSWORD }}